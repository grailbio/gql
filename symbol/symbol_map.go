// Code generated by " ../../../../github.com/grailbio/base/gtl/generate.py --prefix=symbol --PREFIX=Symbol --package=symbol --output=symbol_map.go -DKEY=string -DVALUE=ID -DHASH=hashSymbolName ../../../../github.com/grailbio/base/gtl/rcu_map.go.tpl ". DO NOT EDIT.

package symbol

import (
	"sync/atomic"
	"unsafe"
)

// SymbolMap is a concurrent map. A reader can access the map without lock,
// regardless of background updates.  The writer side must coordinate using an
// external mutex if there are multiple writers. This map is linearizable.
//
// Example:
//
//   m := NewSymbolMap(10)
//   go func() {  // writer
//     m.Store("foo", "bar")
//   }()
//   go func() {  // reader
//     val, ok := m.Load("foo")
//   }
type SymbolMap struct {
	p unsafe.Pointer // *symbolMapState
}

// SymbolMapState represents a fixed-size chained hash table. It can store up to
// maxCapacity key/value pairs.  Beyond that, the caller must create a new
// SymbolMapState with a larger capacity.
type symbolMapState struct {
	log2Len     uint             // ==log2(len(table))
	mask        uint64           // == ^(log2Len-1)
	table       []unsafe.Pointer // *symbolMapNode
	n           int              // # of objects currently stored in the table
	maxCapacity int              // max # of object that can be stored
}

// SymbolMapNode represents a hash bucket.
type symbolMapNode struct {
	key   string
	value ID

	// next points to the next element in the same hash bucket
	next unsafe.Pointer // *symbolMapNode
}

func newSymbolMapState(log2Len uint) *symbolMapState {
	len := int(1 << log2Len)
	table := &symbolMapState{
		log2Len:     log2Len,
		mask:        uint64(log2Len - 1),
		table:       make([]unsafe.Pointer, 1<<log2Len),
		maxCapacity: int(float64(len) * 0.8),
	}
	if table.maxCapacity < len {
		table.maxCapacity = len
	}
	return table
}

// NewSymbolMap creates a new map. Arg initialLenHint suggests the the initial
// capacity.  If you plan to store 100 keys, then pass 100 as the value. If you
// don't know the capacity, pass 0 as initialLenHint.
func NewSymbolMap(initialLenHint int) *SymbolMap {
	log2Len := uint(3) // 8 nodes
	for (1 << log2Len) < initialLenHint {
		if log2Len > 31 {
			// TODO(saito) We could make the table to grow larger than 32 bits, but
			// doing so will break 32bit builds.
			panic(initialLenHint)
		}
		log2Len++
	}
	m := SymbolMap{p: unsafe.Pointer(newSymbolMapState(log2Len))}
	return &m
}

// Load finds a value with the given key. Returns false if not found.
func (m *SymbolMap) Load(key string) (ID, bool) {
	hash := hashSymbolName(key)
	table := (*symbolMapState)(atomic.LoadPointer(&m.p))
	b := int(hash & table.mask)
	node := (*symbolMapNode)(atomic.LoadPointer(&table.table[b]))
	for node != nil {
		if node.key == key {
			return node.value, true
		}
		node = (*symbolMapNode)(atomic.LoadPointer(&node.next))
	}
	var dummy ID
	return dummy, false
}

// store returns false iff the table needs resizing.
func (t *symbolMapState) store(key string, value ID) bool {
	var (
		hash     = hashSymbolName(key)
		b        = int(hash & t.mask)
		node     = (*symbolMapNode)(t.table[b])
		probeLen = 0
		prevNode *symbolMapNode
	)
	for node != nil {
		if node.key == key {
			newNode := *node
			newNode.value = value
			if prevNode == nil {
				atomic.StorePointer(&t.table[b], unsafe.Pointer(&newNode))
			} else {
				atomic.StorePointer(&prevNode.next, unsafe.Pointer(&newNode))
			}
			return true
		}
		prevNode = node
		node = (*symbolMapNode)(node.next)
		probeLen++
		if probeLen >= 4 && t.n >= t.maxCapacity {
			return false
		}
	}
	newNode := symbolMapNode{key: key, value: value}
	if prevNode == nil {
		atomic.StorePointer(&t.table[b], unsafe.Pointer(&newNode))
	} else {
		atomic.StorePointer(&prevNode.next, unsafe.Pointer(&newNode))
	}
	t.n++
	return true
}

// Store stores the value for the given key. If the key is already in the map,
// it updates the mapping to the given value.
//
// Caution: if Store() is going to be called concurrently, it must be serialized
// externally.
func (m *SymbolMap) Store(key string, value ID) {
	table := (*symbolMapState)(atomic.LoadPointer(&m.p))
	if table.store(key, value) {
		return
	}
	log2Len := table.log2Len + 1
	if log2Len > 31 {
		panic(log2Len)
	}
	newTable := newSymbolMapState(log2Len)
	// Copy the contents of the old table over to the new table.
	for _, p := range table.table {
		node := (*symbolMapNode)(p)
		for node != nil {
			if !newTable.store(node.key, node.value) {
				panic(node)
			}
			node = (*symbolMapNode)(node.next)
		}
	}
	if !newTable.store(key, value) {
		panic(key)
	}
	atomic.StorePointer(&m.p, unsafe.Pointer(newTable))
}
